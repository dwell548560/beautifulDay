#ifndef __MODBUS_COMMON_H__
#define __MODBUS_COMMON_H__

#include <stdint.h>
#include <vector>

#define MODBUS_REG_ADDRESS_FRAG_SIZ					(0x400)
#define MODBUS_REG_ADDRESS_MAP_TYPE(addr)			((int)((addr)/MODBUS_REG_ADDRESS_FRAG_SIZ))
#define MODBUS_REG_ADDRESS_INDEX(addr)				((int)((addr)%MODBUS_REG_ADDRESS_FRAG_SIZ))
#define MODBUS_INPUT_REG_ADDRESS_MAP_TYPE(addr)		MODBUS_REG_ADDRESS_MAP_TYPE(addr - MODBUS_INPUT_REG_ADDRESS_OFFSET)

#define MODBUS_COMMON_REG_ADDRESS						0x0000
#define MODBUS_GUAWANG_REG_ADDRESS					0x0400
#define MODBUS_DIZHUAN1_REG_ADDRESS					0x0800
#define MODBUS_PAINT_REG_ADDRESS						0x0C00
#define MODBUS_WALLHANDING_REG_ADDRESS				0x1000
#define MODBUS_WALLINSTALL_REG_ADDRESS				0x1400

#define MODBUS_WALLPAPER_REG_ADDRESS					0x1800
#define MODBUS_CEILINGPOLISH_REG_ADDRESS			0x2000				
#define MODBUS_INSIDE_WALLPOLISH_REG_ADDRESS	0x2400
#define MODBUS_INPUT_REG_ADDRESS_OFFSET				0x4000

#define MODBUS_COMMON_REG_INDEX						MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_COMMON_REG_ADDRESS)
#define MODBUS_GUAWANG_REG_INDEX					MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_GUAWANG_REG_ADDRESS)
#define MODBUS_DIZHUAN1_REG_INDEX					MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_DIZHUAN1_REG_ADDRESS)
#define MODBUS_PAINT_REG_INDEX						MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_PAINT_REG_ADDRESS)
#define MODBUS_WALLHANDING_REG_INDEX				MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_WALLHANDING_REG_ADDRESS)
#define MODBUS_WALLINSTALL_REG_INDEX				MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_WALLINSTALL_REG_ADDRESS)
#define MODBUS_INPUT_REG_INDEX_OFFSET				MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_INPUT_REG_ADDRESS_OFFSET)

#define MODBUS_WALLPAPER_REG_INDEX					MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_WALLPAPER_REG_ADDRESS)
#define MODBUS_CEILINGPOLISH_REG_INDEX			MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_CEILINGPOLISH_REG_ADDRESS)
#define MODBUS_INSIDE_WALLPOLISH_REG_INDEX	MODBUS_REG_ADDRESS_MAP_TYPE(MODBUS_INSIDE_WALLPOLISH_REG_ADDRESS)

enum AGVModbusRosFuncCode {
	ROS_TO_MODBUS_CMD_WRITE = 0x05,
	ROS_TO_MODBUS_CMD_READ = 0x06,
	ROS_MODBUS_CMD_STATUS = 0x07,
};

enum _CmdStatus {
	ROS_MODBUS_CMD_OK = 0x01,
	ROS_MODBUS_CMD_FAILED,
};

enum ModbusCommonHoldingRegisters {
	AGV_REGISTERS_ADDRESS_FORWARD = 0x0000,
	AGV_REGISTERS_ADDRESS_FORWARD_SPEED = 0x0001,
	AGV_REGISTERS_ADDRESS_BACKOFF = 0x0002,
	AGV_REGISTERS_ADDRESS_BACKOFF_SPEED = 0x0003,
	AGV_REGISTERS_ADDRESS_LEFT_SHIFT = 0x0004,
	AGV_REGISTERS_ADDRESS_LEFT_SHIFT_SPEED = 0x0005,
	AGV_REGISTERS_ADDRESS_RIGHT_SHIFT = 0x0006,
	AGV_REGISTERS_ADDRESS_RIGHT_SHIFT_SPEED = 0x0007,
	AGV_REGISTERS_ADDRESS_LEFT_TURN = 0x0008,
	AGV_REGISTERS_ADDRESS_LEFT_TURN_SPEED = 0x0009,
	AGV_REGISTERS_ADDRESS_RIGHT_TURN = 0x000A,
	AGV_REGISTERS_ADDRESS_RIGHT_TURN_SPEED = 0x000B,
	AGV_REGISTERS_ADDRESS_MAX_SPEED = 0x000C,
	AGV_REGISTERS_ADDRESS_SPEED_PERCENT = 0x000D,
	AGV_REGISTERS_ADDRESS_CLICK_FORWARD_SPEED = 0x000E,
	AGV_REGISTERS_ADDRESS_CLICK_BACK_SPEED = 0x000F,
	AGV_REGISTERS_ADDRESS_CLICK_LEFT_SPEED = 0x0010,
	AGV_REGISTERS_ADDRESS_CLICK_RIGHT_SPEED = 0x0011,
	AGV_REGISTERS_ADDRESS_STATION_SET = 0x0012,
	AGV_REGISTERS_ADDRESS_TASK_CONTROL = 0x0014,
	AGV_REGISTERS_ADDRESS_ROTATE = 0x0015,
	AGV_REGISTERS_ADDRESS_MAPPING = 0x0017,
	AGV_REGISTERS_ADDRESS_EMERGENCY_STOP_RESET = 0x0018,
	AGV_REGISTERS_ADDRESS_SENSOR_SWITCH = 0x0019,
	AGV_REGISTERS_ADDRESS_POSE_X = 0x001B,
	AGV_REGISTERS_ADDRESS_POS_Y = 0x001D,
	AGV_REGISTERS_ADDRESS_POSE_YAW = 0x001F,
};

enum CommonInputRegisters {
	AGV_INPUT_REGISTERS_ADDRESS_STATUS = 0x4000,
	AGV_INPUT_REGISTERS_ADDRESS_STATION_TOTAL = 0x4001,
	AGV_INPUT_REGISTERS_ADDRESS_STATION_GET = 0x4003,
	AGV_INPUT_REGISTERS_ADDRESS_AT_HOME = 0x4005,
	AGV_INPUT_REGISTERS_ADDRESS_FAULT_STATUS = 0x4006,
	AGV_INPUT_REGISTERS_ADDRESS_SENSOR_STATUS = 0x4007,
	AGV_INPUT_REGISTERS_ADDRESS_POSE_X = 0x4009,
	AGV_INPUT_REGISTERS_ADDRESS_POSE_Y = 0x400B,
	AGV_INPUT_REGISTERS_ADDRESS_POSE_YAW = 0x400D,
	AGV_INPUT_REGISTERS_ADDRESS_CURRENT_SPEED = 0x400F,
	AGV_INPUT_REGISTERS_ADDRESS_ODOM = 0x4010,
	AGV_INPUT_REGISTERS_ADDRESS_PATH_PLANNING = 0x4012,
	AGV_INPUT_REGISTERS_ADDRESS_IN_POSITION = 0x4013,
};

// no need to map
enum PowerBoardHoldingRegisters {
	POWER_BOARD_REGISTERS_ADDRESS_OUT0 = 0x0300,
	POWER_BOARD_REGISTERS_ADDRESS_OUT1 = 0x0301,
	POWER_BOARD_REGISTERS_ADDRESS_OUT2 = 0x0302,
	POWER_BOARD_REGISTERS_ADDRESS_OUT3 = 0x0303,
	POWER_BOARD_REGISTERS_ADDRESS_OUT4 = 0x0304,
	POWER_BOARD_REGISTERS_ADDRESS_OUT5 = 0x0305,
	POWER_BOARD_REGISTERS_ADDRESS_OUT6 = 0x0306,
	POWER_BOARD_REGISTERS_ADDRESS_OUT7 = 0x0307,
	POWER_BOARD_REGISTERS_ADDRESS_RLY1 = 0x0308,
	POWER_BOARD_REGISTERS_ADDRESS_RLY2 = 0x0309,
	POWER_BOARD_REGISTERS_ADDRESS_RLY3 = 0x030A,
	POWER_BOARD_REGISTERS_ADDRESS_RLY4 = 0x030B,
	POWER_BOARD_REGISTERS_ADDRESS_RLY5 = 0x030C,
	POWER_BOARD_REGISTERS_ADDRESS_RLY6 = 0x030D,
	POWER_BOARD_REGISTERS_ADDRESS_RLY7 = 0x030E,
	POWER_BOARD_REGISTERS_ADDRESS_POWER_SWITCH = 0x030F,
};

// no need to map
enum PowerBoardInputRegisters {
	POWER_BOARD_INPUT_REGISTERS_ADDRESS_INPUT = 0x4300,
	POWER_BOARD_INPUT_REGISTERS_ADDRESS_EMERGENCY_STOP = 0x4301,
	POWER_BOARD_INPUT_REGISTERS_ADDRESS_POWER_STATUS = 0x4302,
	POWER_BOARD_INPUT_REGISTERS_ADDRESS_ADC_CH0 = 0x4303,
	POWER_BOARD_INPUT_REGISTERS_ADDRESS_ADC_CH1 = 0x4304,
	POWER_BOARD_INPUT_REGISTERS_ADDRESS_ADC_CH2 = 0x4305,
	POWER_BOARD_INPUT_REGISTERS_ADDRESS_ADC_CH3 = 0x4306,
};

// 天花打磨
enum CeilingPolishRegister {
	// holding registers
	AGV_STATUS_REGISTERS_ADDRESS_TASK_ID = 0x1800,
	AGV_STATUS_REGISTERS_ADDRESS_EXEC_DEVICE_STATUS = 0x1801,

	// input registers
	AGV_INPUT_REGISTERS_ADDRESS_TASK_ID = 0x5800,
	AGV_INPUT_REGISTERS_ADDRESS_TASK_TYPE = 0x5801,
	AGV_INPUT_REGISTERS_ADDRESS_TARGET_HEIGHT_L = 0x5802,
	AGV_INPUT_REGISTERS_ADDRESS_TARGET_HEIGHT_H = 0x5803,
	AGV_INPUT_REGISTERS_ADDRESS_CEILING_HEIGHT_L = 0x5804,
	AGV_INPUT_REGISTERS_ADDRESS_CEILING_HEIGHT_H = 0x5806,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_NUM = 0x5806,

	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_0 = 0x5820,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_1 = 0x5821,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_2 = 0x5822,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_3 = 0x5823,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_4 = 0x5824,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_5 = 0x5825,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_6 = 0x5826,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_7 = 0x5827,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_8 = 0x5828,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_9 = 0x5829,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_10 = 0x5830,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_11 = 0x5831,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_12 = 0x5832,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_13 = 0x5833,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_14 = 0x5834,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_15 = 0x5835,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_16 = 0x5836,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_17 = 0x5837,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_18 = 0x5838,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_19 = 0x5839,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_20 = 0x5840,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_21 = 0x5841,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_22 = 0x5842,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_23 = 0x5843,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_24 = 0x5844,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_25 = 0x5845,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_26 = 0x5846,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_27 = 0x5847,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_28 = 0x5848,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_29 = 0x5849,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_30 = 0x5850,
	AGV_INPUT_REGISTERS_ADDRESS_GAP_INDEX_31 = 0x5851,
};

enum GWTJHoldingRegisters {
	AGV_REGISTERS_ADDRESS_CAMERA_RANGING = 0x0400,
};

enum GWTJInputRegisters {
	AGV_INPUT_REGISTERS_ADDRESS_ACTION = 0x4400,
};

enum DiZhuan1HoldingRegisters {
	AGV_REGISTERS_ADDRESS_IPC_RUNNING_STATUS = 0x0800,
	AGV_REGISTERS_ADDRESS_LEFT_SPEED = 0x0801,
	AGV_REGISTERS_ADDRESS_RIGHT_SPEED = 0x0802,
	AGV_REGISTERS_ADDRESS_LEFT_RUDDER_ANGLE = 0x0803,
	AGV_REGISTERS_ADDRESS_RIGHT_RUDDER_ANGLE = 0x0805,
	AGV_REGISTERS_ADDRESS_MAX_ACCELERATION = 0x0807,
	AGV_REGISTERS_ADDRESS_MIN_ACCELERATION = 0x0808,
	AGV_REGISTERS_ADDRESS_JERK_MAX = 0x0809,
	AGV_REGISTERS_ADDRESS_JERK_MIN = 0x080A,
	AGV_REGISTERS_ADDRESS_PID_LINEKP = 0x080B,
	AGV_REGISTERS_ADDRESS_PID_LINEKI = 0x080C,
	AGV_REGISTERS_ADDRESS_PID_LINEKD = 0x080D,
	AGV_REGISTERS_ADDRESS_PID_ROTATEKP = 0x080E,
	AGV_REGISTERS_ADDRESS_PID_ROTATEKI = 0x080F,
	AGV_REGISTERS_ADDRESS_PID_ROTATEKD = 0x0810,
	AGV_REGISTERS_ADDRESS_LWHEELDIAMETER = 0x0811,
	AGV_REGISTERS_ADDRESS_RWHEELDIAMETER = 0x0812,
	AGV_REGISTERS_ADDRESS_WHEELSDISTANCE = 0x0813,
};

enum DiZhuan1InputRegisters {
	AGV_INPUT_REGISTERS_ADDRESS_LEFT_MOTOR_ANGLE = 0x4800,
	AGV_INPUT_REGISTERS_ADDRESS_RIGHT_MOTOR_ANGLE = 0x4802,
	AGV_INPUT_REGISTERS_ADDRESS_ATTRIBUTE = 0x4804,
	AGV_INPUT_REGISTERS_ADDRESS_IPC_START_STOP = 0x4805,
	AGV_INPUT_REGISTERS_ADDRESS_START_POINT_X = 0x4806,
	AGV_INPUT_REGISTERS_ADDRESS_START_POINT_Y = 0x4808,
	AGV_INPUT_REGISTERS_ADDRESS_START_POINT_ORIENTATION = 0x480A,
	AGV_INPUT_REGISTERS_ADDRESS_TARGET_POINT_X = 0x480C,
	AGV_INPUT_REGISTERS_ADDRESS_TARGET_POINT_Y = 0x480E,
	AGV_INPUT_REGISTERS_ADDRESS_TARGET_POINT_ORIENTATION = 0x4810,
	AGV_INPUT_REGISTERS_ADDRESS_LINE_MAX_SPEED = 0x4812,
	AGV_INPUT_REGISTERS_ADDRESS_SPIN_AROUND_SPEED = 0x4813,
	AGV_INPUT_REGISTERS_ADDRESS_RUNNING_MODE = 0x4814,
	AGV_INPUT_REGISTERS_ADDRESS_MOTOR_CYCLE = 0x4815,
};

enum PaintHoldingRegisters {
	AGV_REGISTERS_ADDRESS_STATION_TYPE = 0x0C00,
	AGV_REGISTERS_ADDRESS_PAINT_BEGIN_HIGH_FEEDBACK = 0x0C01,
	AGV_REGISTERS_ADDRESS_PAINT_END_HIGH_FEEDBACK = 0x0C03,
	AGV_REGISTERS_ADDRESS_PAINT_WIDTH_FEEDBACK_OR_SHIFTING_DISTANCE = 0x0C05,
	AGV_REGISTERS_ADDRESS_PAINT_DEPTH_FEEDBACK = 0x0C06,
	AGV_REGISTERS_ADDRESS_PAINT_STEP_FEEDBACK = 0x0C07,
	AGV_REGISTERS_ADDRESS_PAINT_STATUS = 0x0C09,
	AGV_REGISTERS_ADDRESS_PAINT_TOTAL_STATUS = 0x0C0A,
	AGV_REGISTERS_ADDRESS_PAINT_MOVE_ALLOW = 0x0C0B,
};

enum PaintInputRegisters {
	AGV_INPUT_REGISTERS_ADDRESS_AGV_MODE = 0x4C00,
	AGV_INPUT_REGISTERS_ADDRESS_AGV_STATUS = 0x4C01,
	AGV_INPUT_REGISTERS_ADDRESS_STATION_TYPE = 0x4C02,
	AGV_INPUT_REGISTERS_ADDRESS_PAINT_BEGIN_HIGH = 0x4C03,
	AGV_INPUT_REGISTERS_ADDRESS_PAINT_END_HIGH = 0x4C05,
	AGV_INPUT_REGISTERS_ADDRESS_PAINT_WIDTH_OR_SHIFTING_DISTANCE = 0x4C07,
	AGV_INPUT_REGISTERS_ADDRESS_PAINT_DEPTH = 0x4C08,
	AGV_INPUT_REGISTERS_ADDRESS_PAINT_STEP = 0x4C09,
	AGV_INPUT_REGISTERS_ADDRESS_PAINT_ACTION = 0x4C0B,
	AGV_INPUT_REGISTERS_ADDRESS_PAINT_MOVE_REQUEST = 0x4C0C,
};

// no need to map
enum WallHandlingHoldingRegisters {
	AGV_REGISTERS_ADDRESS_MECH_AT_HOME = 0x1000,
	AGV_REGISTERS_ADDRESS_PREPARE_WALL_LOADING = 0x1001,
	AGV_REGISTERS_ADDRESS_WALL_LOADING = 0x1002,
	AGV_REGISTERS_ADDRESS_PACKUP_FORK = 0x1003,
	AGV_REGISTERS_ADDRESS_PREPARE_WALL_UNLOADING = 0x1004,
	AGV_REGISTERS_ADDRESS_WALL_UNLOADING = 0x1005,
	AGV_REGISTERS_ADDRESS_WALL_MECH_STOP = 0x1006,
	AGV_REGISTERS_ADDRESS_WALL_HANDLING_STOP = 0x1007,
	AGV_REGISTERS_ADDRESS_WALL_HANDLING_EMERGENCY_STOP = 0x1008,
};

// no need to map
enum WallHandlingInputRegisters {
	AGV_INPUT_REGISTERS_ADDRESS_MECH_AT_HOME = 0x5000,
	AGV_INPUT_REGISTERS_ADDRESS_PREPARE_WALL_LOADING = 0x5001,
	AGV_INPUT_REGISTERS_ADDRESS_WALL_LOADING = 0x5002,
	AGV_INPUT_REGISTERS_ADDRESS_PACKUP_FORK = 0x5003,
	AGV_INPUT_REGISTERS_ADDRESS_PREPARE_WALL_UNLOADING = 0x5004,
	AGV_INPUT_REGISTERS_ADDRESS_WALL_UNLOADING = 0x5005,
	AGV_INPUT_REGISTERS_ADDRESS_WALL_MECH_STOP = 0x5006,
	AGV_INPUT_REGISTERS_ADDRESS_WALL_ALARM = 0x5007,
};

enum WallInstallHoldingRegisters {
	AGV_REGISTERS_ADDRESS_UPPER_END_FAULT_TATUS = 0x1400,
	AGV_REGISTERS_ADDRESS_UPPER_END_FAULT_CODE = 0x1401,
	AGV_REGISTERS_ADDRESS_UPPER_END_STATUS = 0x1402,
	AGV_REGISTERS_ADDRESS_UPPER_END_RUNNING_STATUS = 0x1403,
	AGV_REGISTERS_ADDRESS_UPPER_END_EXECUTION_RESULTS = 0x1404,
};

enum WallInstallInputRegisters {
	AGV_INPUT_REGISTERS_ADDRESS_WORKING_MODE = 0x5400,
	AGV_INPUT_REGISTERS_ADDRESS_CHASSIS_RUNNING_STATE = 0x5401,
	AGV_INPUT_REGISTERS_ADDRESS_CHASSIS_MOBILE_STATE = 0x5402,
};

#ifndef SUBSCRIBE_QUEUE_BUF_LEN
#define SUBSCRIBE_QUEUE_BUF_LEN         (10)
#endif

#ifndef SUBSCRIBE_MODUBS_TOPIC
#define SUBSCRIBE_MODUBS_TOPIC         "modbus_to_ros"
#endif

#ifndef PUBLISH_MODUBS_TOPIC
#define PUBLISH_MODUBS_TOPIC           "ros_to_modbus"
#endif

// modbus帧消息转化结构体
typedef struct
{
	uint8_t  cmd;
	uint16_t addr;
	uint16_t num;
	std::vector<uint16_t> data;
} ModbusMessage;

typedef struct
{
  uint8_t cmd;
  uint8_t status;
  ModbusMessage msg;
} ModbusResponse;

#if 0
#include "agv_task_control/Modbus.h"
namespace agv_task_control
{

	/**
	 * @brief	send modbus command
	 * @cmd		read or write
	 * @addr	read or write register's addr
	 * 			holding-registers for read, input-registers for write
	 * @cmd_siz	sizeof(cmd_param), must be multiple of 2
	 * 			If it is odd, the last byte will be discarded
	 * @cmd_param	cmd data
	 * @return 0: ok, -1: failed
	 *
	 */
	int send_modbus_command(uint8_t cmd, uint16_t addr, uint16_t cmd_size, uint8_t *cmd_param);

	/**
	 * @brief init communicate with modbus
	 *
	 * @param nh node handle
	 * @param modbus_to_ros_cb will be called while msg from topic modbus_to_ros received
	 */
	void init_modbus_base(ros::NodeHandle *nh, void (*modbus_to_ros_cb)(const ModbusMessage *msg));
	void deinit_modbus_base(ros::NodeHandle *nh);
} // namespace agv_task_control
#endif

#endif /*__MODBUS_COMMON_H__ */
